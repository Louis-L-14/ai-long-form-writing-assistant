- 需求

  - 业务需求

    # 第一部分：业务需求说明书

    ## 1. 项目背景与核心价值

    本项目旨在构建一个**基于 LLM + Agent 的长篇网文辅助写作系统**。 其核心解决痛点是：LLM 在长文本生成中容易“遗忘设定”、“逻辑崩坏”以及“缺乏全局掌控力”。 系统的核心价值在于：

    1. **结构化引导**：通过标准化流程，将模糊灵感转化为可执行的严谨设定（前期工作）。
    2. **动态记忆 (RAG)**：利用基于时间/章节维度的 RAG 策略，确保数百万字写作中的设定一致性。
    3. **灵活干预**：允许作者在写作过程中随时插入新想法，系统能自动级联更新相关的大纲和设定，实现“设定随剧情演化”。

    ## 2. 核心功能模块拆解

    我们将系统划分为三个核心业务域：**创作引导域（前期）**、**正文写作域（中期）**、**设定管理域（全周期）**。

    ### 2.1 创作引导域 (Project Initialization)

    *通过对话式 Agent 引导用户完成。*

    ### F1. 创意孵化 (Idea Incubator)

    - **功能描述**：用户输入模糊灵感，LLM 结合网络搜索（Web Search）分析当前网文市场热点，输出书名、一句话梗概、核心卖点（爽点）。
    - **Web Search 应用**：自动检索同类型热门小说的书名、开篇节奏作为参考。

    ### F2. 世界观搭建 (World Builder)

    - **功能描述**：引导用户确立力量体系、地图、势力、经济系统。
    - **输出物**：结构化的世界观文档（后续存入 RAG 数据库）。

    ### F3. 角色工厂 (Character Foundry)

    - **功能描述**：生成主角及核心配角/反派的详细档案（外貌、性格、金手指、人际关系）。
    - **关键特性**：为每个角色生成“初始版本（Version 1）”，并绑定“第 1 章”作为生效起点。

    ### F4. 结构编排 (Story Architect)

    - **功能描述**：
      1. 生成**全书主线**（起承转合）。
      2. 生成**分卷大纲**（以换地图为节点）。
      3. 生成**细纲**（前 10-20 章的章纲，包含核心冲突和伏笔）。

    ------

    ### 2.2 正文写作域 (Writing Workbench)

    *这是用户最高频使用的界面，核心是“逐章生成”。*

    ### F5. 智能章节生成 (AI Writing Agent)

    - **输入处理**：用户选择“生成下一章”或“生成下一片段”。
    - **RAG 检索流**：系统自动检索当前章节需要用到的：
      - 当前生效的人物卡（注意版本控制）。
      - 当前场景的地理/势力设定。
      - 前文摘要（Context）。
      - 本章大纲（来自 F4）。
    - **生成执行**：LLM 基于检索内容进行撰写。

    ### F6. 动态干预与指令覆写 (Dynamic Intervention)

    - **场景**：用户在生成前（或生成不满意时）输入：“*这章在这个情节，让主角突然决定杀掉反派，而不是原定的放走他。*”
    - **Agent 决策链**：
      1. **识别冲突**：Agent 识别到用户指令与原定大纲/人设冲突。
      2. **自动修正**：Agent 调用工具（Tools）修改后续大纲、更新反派状态为“死亡”（并在数据库中生成新版本设定）。
      3. **执行写作**：在更新完所有依赖数据后，再执行正文写作。

    ### F7. 写作助手工具箱 (Writing Toolkit)

    - **即时素材调用**：侧边栏提供“随机取名”、“功法描写”、“环境描写”等快捷生成按钮（基于前期生成的素材库）。
    - **一致性检查**：写完一段后，后台 Agent 自动比对正文与设定，若发现主角性格崩坏或吃书（设定冲突），在 UI 上高亮警示。

    ------

    ### 2.3 设定管理域 (Knowledge & Asset Management)

    *这是 RAG 的后台维护中心，对用户透明但至关重要。*

    ### F8. 动态百科全书 (Dynamic Wiki)

    - **功能描述**：一个可视化的设定集页面。
    - **版本时间轴**：用户可以查看“艾琳”这个角色在第 1 章是“村姑”，在第 50 章变成“圣女”的演变过程（对应数据库中的 version 和 chapter_range）。
    - **手动修订**：用户可以手动修改某条设定，系统自动询问：“该修改是从第几章开始生效？”并据此更新 RAG 索引。

    ### F9. 进度看板 (Dashboard)

    - **功能描述**：展示当前字数、已写章节、待写大纲进度。

    ------

    ## 3. 用户业务流程 (User Journey)

    ### 阶段一：建号（Onboarding）

    1. 用户进入首页，点击“新建作品”。
    2. 进入**向导模式**：
       - Agent: “你想写什么类型？” -> User: “赛博修仙”。
       - Agent (搜索后): “目前这几本很火...建议设定为...”。
       - ... (依次完成世界观、人物、大纲) ...
    3. 确认生成**项目知识库**（此时 RAG 数据库完成初始化）。

    ### 阶段二：日常更新（Daily Writing）

    1. 用户进入**写作工作台**。
    2. 系统自动加载“第 N 章”的细纲。
    3. 用户点击“生成草稿”。
       - *(后台 Agent 检索设定 -> 写入 Prompt -> 生成)*
    4. 用户查看生成的草稿。
    5. **分支情况 A (满意)**：用户微调文字 -> 点击“定稿/下一章” -> 系统自动摘要本章内容存入记忆库 -> 角色状态若有变更（如升级），系统提示是否更新人物卡。
    6. **分支情况 B (突发奇想)**：
       - 用户输入：“这章加个新角色，是个女刺客。”
       - Agent 弹窗：“检测到新角色，请简要描述她的特征，我先建立人物卡。”
       - 用户确认后，Agent 建卡入库，然后重新生成正文。

    ------

    ## 4. 关键业务规则

    1. **设定优先原则**：除非用户明确发出“修改设定”的指令，否则 AI 写作必须严格遵循 RAG 检索到的当前版本设定。
    2. **版本不回溯原则**：修改第 50 章的设定（如主角断臂），不应影响第 1-49 章的阅读体验（前文检索到的依然是双臂健全的主角）。
    3. **Web Search 使用边界**：主要用于“创意孵化阶段”查找梗概和竞品，以及“正文写作阶段”查找特定知识（如“宋朝的官制”、“量子力学的名词”），不用于检索用户自己的私有设定。

  - 技术需求

    # 第二部分：技术需求说明书 (Technical Requirements Document)

    ## 1. 技术选型 (Tech Stack)

    ### 1.1 核心架构

    采用 **Micro-service Architecture (微服务架构)** 的变体，前后端分离，AI 服务独立编排。

    - **前端 (Frontend)**:
      - **框架**: Next.js 14+ (App Router) - 利用其服务端渲染 (SSR) 和流式传输 (Streaming) 能力。
      - **状态管理**: Zustand (轻量级) 或 Redux Toolkit - 用于管理复杂的创作工作台状态（如侧边栏设定、当前正文、聊天历史）。
      - **UI 组件库**: Shadcn/ui + Tailwind CSS - 快速构建现代、简洁的编辑器界面。
      - **编辑器核心**: Tiptap 或 ProseMirror - 支持富文本与 Markdown，方便后续扩展“批注”和“高亮”功能。
    - **后端 (Backend)**:
      - **API 框架**: FastAPI (Python) - 高性能，原生支持异步 (Async)，完美契合 LLM 的流式响应 (Server-Sent Events, SSE)。
      - **数据验证**: Pydantic - 确保 LLM 输出的结构化数据（如人物卡 JSON）符合定义。
    - **AI 与编排 (AI Orchestration)**:
      - **框架**: LangChain (基础组件) + **LangGraph** (核心编排) - LangGraph 是实现有状态、循环、多步推理 Agent 的关键，特别适合处理“写-评-改”的循环工作流。
      - **LLM 模型**: 支持多模型切换。主力模型建议 GPT-4o 或 Claude 3.5 Sonnet (逻辑与文笔较好)，成本考虑可接入 DeepSeek-V3。
      - **Web Search Tool**: Tavily API (专为 AI Agent 优化的搜索) 或 DuckDuckGo Search (免费方案)。
    - **数据库与存储 (Data Persistence)**:
      - **主数据库**: PostgreSQL (v15+) - **核心决策**。
      - **向量扩展**: `pgvector` - 将关系型数据与向量数据存放在同一个库中，极大简化“基于元数据（Metadata）的混合检索”逻辑。
      - **缓存**: Redis (可选) - 用于缓存热门章节的上下文或用户会话状态。

    ------

    ## 2. 核心数据架构设计 (Database Schema)

    基于你提供的 RAG 策略，这是实现“时间旅行”和“版本控制”的关键 Schema 设计。

    ### 2.1 关系型 + 向量融合表结构

    我们需要严格区分“实体 (Entity)”和“版本 (Version)”。

    **A. 项目表 (Projects)**

    - `id`: UUID
    - `user_id`: UUID
    - `current_chapter_index`: Integer (当前写到第几章)

    **B. 章节表 (Chapters)**

    - `id`: UUID
    - `project_id`: FK
    - `chapter_number`: Integer (序号，如 8)
    - `content`: Text (正文内容)
    - `summary`: Text (本章摘要，用于 RAG 上下文)

    **C. 实体版本表 (Entity_Versions) - 核心表***包含人物、地点、势力、道具等所有设定。*

    - `id`: UUID
    - `project_id`: FK
    - `entity_type`: Enum ('character', 'location', 'item', 'plot_point')
    - `entity_id`: UUID (逻辑 ID，例如“艾琳”这个概念的 ID，不变)
    - `version`: Integer (版本号，如 1, 2, 3)
    - `valid_from_chapter`: Integer (生效起始章)
    - `valid_to_chapter`: Integer (失效结束章，NULL 代表当前一直有效)
    - `is_active`: Boolean (当前最新版本标记)
    - `data`: JSONB (结构化详情：性格、等级、关系等)
    - `embedding`: Vector(1536) (基于 `data` 生成的文本摘要的向量)

    ### 2.2 检索策略 (RAG Query Logic)

    当 Agent 需要为 **第 N 章** 生成内容时，SQL 查询逻辑如下：

    ```sql
    SELECT data, entity_type
    FROM entity_versions
    WHERE project_id = :current_project_id
      AND (
          -- 向量相似度匹配 (Semantic Search)
          embedding <=> :query_vector < 0.3
      )
      AND (
          -- 时间/章节过滤 (Time-Travel Filtering)
          valid_from_chapter <= :N
          AND (valid_to_chapter IS NULL OR valid_to_chapter >= :N)
      )
    ORDER BY embedding <=> :query_vector ASC;
    ```

    *这确保了 Agent 绝不会在第 10 章“看到”第 50 章才发生的断臂设定。*

    ------

    ## 3. LangGraph Agent 编排流程

    这是系统的“大脑”，我们需要设计一个 **Stateful Graph (有状态图)**。

    ### 3.1 Graph 状态定义 (StateSchema)

    在 LangGraph 中流转的数据包：

    ```python
    class AgentState(TypedDict):
        messages: List[BaseMessage]  # 对话历史
        current_chapter: int         # 当前章节号
        context_data: str            # RAG 检索到的背景信息
        draft_content: str           # 生成的草稿
        user_intent: str             # 用户意图 (writing, updating_settings, chatting)
        web_search_results: str      # 网络搜索结果
    ```

    ### 3.2 核心节点 (Nodes) 设计

    我们需要构建一个 **Supervisor (监督者/路由)** 模式的图：

    1. **Input Node (用户输入)**: 接收用户指令。
    2. **Intent Classifier (意图识别)**:
       - 分析用户输入是想“继续写正文”、“查询资料”还是“修改设定”。
       - *路由逻辑*: -> `WebSearchNode` / `SettingManagerNode` / `WriterNode`.
    3. **WebSearch Node**:
       - 调用 Tavily API 搜索（如“赛博朋克风格的义肢型号”）。
       - 将结果存入 State。
    4. **Setting Manager Node (动态设定管理)**:
       - **核心功能**: 处理用户的“临时想法”。
       - *动作*:
         1. 提取新设定的实体信息。
         2. 更新 `Entity_Versions` 表（执行 Close Old Version -> Insert New Version 操作）。
         3. 重新触发 RAG 索引更新。
    5. **Retrieval Node (RAG 增强)**:
       - 根据 `current_chapter` 和任务描述，执行 2.2 中的 SQL 检索。
       - 将设定摘要拼接到 System Prompt 中。
    6. **Writer Node (正文生成)**:
       - 输入: System Prompt (含 RAG Context) + User Instruction + Web Search Results.
       - 输出: 正文流。

    ### 3.3 工作流示例

    **场景：用户在写第 12 章时突然说：“给主角加一把能斩断灵魂的剑，叫‘摄魂’。”**

    1. **Start**: 用户输入指令。
    2. **Intent Classifier**: 识别为 `updating_settings`。
    3. **Setting Manager**:
       - 提取：Item Name='摄魂', Ability='斩断灵魂'。
       - DB操作：Insert into `entity_versions` (ver=1, from=12, type=item)。
       - 反馈：向用户确认“‘摄魂’已添加至设定库，从本章开始生效。”
    4. **Router**: 自动跳转回 `Writer Node`。
    5. **Retrieval Node**: 重新检索，此时能检索到‘摄魂’的设定。
    6. **Writer Node**: 生成带有新武器描写的正文。

    ------

    ## 4. 接口设计 (API Design)

    FastAPI 需要提供以下关键端点：

    ### A. 初始化与引导

    - `POST /api/brainstorm/idea`: 输入灵感，调用 Web Search，返回大纲建议。
    - `POST /api/project/init`: 提交最终设定，批量写入 DB，初始化向量索引。

    ### B. 设定管理

    - `GET /api/project/{id}/wiki`: 获取当前章节视角下的所有有效设定（用于前端 Wiki 展示）。
    - `POST /api/entity/update`: 手动更新某个人物/设定（触发版本迭代逻辑）。

    ### C. 写作与生成 (Streaming)

    - `POST /api/chat/stream`: 核心交互接口。
      - **Input**: `{ message: "生成下一段", chapter_id: 12, project_id: "..." }`
      - **Process**: 触发 LangGraph 运行。
      - **Response**: SSE (Server-Sent Events) 流。
      - **Event Types**:
        - `event: thought` (显示 Agent 的思考过程，如“正在检索艾琳的设定...”)
        - `event: tool_use` (显示“正在搜索网络...”)
        - `event: message` (实际生成的正文内容)

  - 界面设计

    设计核心理念：**左侧管结构，中间管正文，右侧管智能。**

    ------

    # 第三部分：页面与交互设计说明书 (UI/UX Design)

    ## 1. 设计风格指南 (Design System)

    - **配色方案**：推荐默认**深色模式 (Dark Mode)**（Zinc 或 Slate 色系），减少长时间写作的视觉疲劳。AI 相关的操作使用**紫色/靛青色 (Indigo)** 渐变作为强调色，象征智能。
    - **布局架构**：采用 **App Shell** 布局，即顶部导航栏 + 三栏式主体（可折叠）。
    - **字体**：正文使用衬线字体（如 Noto Serif SC / 思源宋体）提供类似书籍的阅读感；界面 UI 使用无衬线字体（Inter / Geist）。

    ------

    ## 2. 核心页面一：项目创世纪 (Genesis Wizard)

    *对应“业务需求 F1-F4”，这是用户创建新书的引导流程。*

    ### 页面布局

    - **分屏设计**：
      - **左侧 (40%) - 对话引导区**：类似 ChatGPT 的聊天界面。Agent 会在这里提问（“你想写什么题材？”）并展示搜索结果。
      - **右侧 (60%) - 设定预览区 (Live Preview)**：实时渲染生成的 JSON 数据。
      - **顶部**：进度步进条 (Step 1: 核心 -> Step 2: 世界 -> Step 3: 人物 -> Step 4: 大纲)。

    ### 关键交互

    1. **动态卡片生成**：
       - 当 Agent 在左侧生成了“主角：林凡”的设定时，右侧会自动弹出一张可视化的**人物卡片**。
       - 用户可以直接在右侧卡片上点击“编辑”按钮手动修改数值，修改后 Agent 会感知并确认。
    2. **Web Search 呈现**：
       - 当 Agent 需要联网搜索（如“查找热门玄幻书名”）时，对话框显示折叠的“搜索源”引用，增加可信度。
    3. **一键确权**：
       - 流程最后一步是“生成项目”，点击后，前端将右侧所有最终确认的 JSON 数据打包发送给后端 `/api/project/init` 接口，完成 RAG 库的初始化。

    ------

    ## 3. 核心页面二：沉浸式写作工作台 (The Studio)

    *对应“业务需求 F5-F7”，这是用户停留时间最长的页面。*

    ### 页面布局 (三栏式)

    ### A. 左侧栏：导航与大纲 (Navigation Sidebar) - *宽 250px, 可折叠*

    - **目录树**：展示卷、章结构。
    - **章节状态标记**：已完结 (绿色)、草稿中 (黄色)、未生成 (灰色)。
    - **本章简纲 (Mini-Outline)**：显示当前选中章节的 3-5 个剧情关键点（来自前期生成的大纲），支持拖拽排序或勾选完成。

    ### B. 中间栏：正文编辑器 (The Canvas) - *自适应宽度*

    - **编辑器核心**：基于 Tiptap 开发。
    - **视觉样式**：模拟 A4 纸张或电子书排版，页边距宽大，行高舒适 (1.8em)。
    - **功能区**：
      - **Ghost Text (幽灵文字)**：AI 生成的内容先以浅灰色显示，用户按 `Tab` 键接受，按 `Esc` 拒绝或重写。
      - **划词交互**：选中一段文字，浮动菜单出现“润色”、“扩写”、“检查冲突”按钮。

    ### C. 右侧栏：AI 协作者 (The Copilot) - *宽 350px*

    这是 **Agent 的驻扎地**，分为三个 Tab：

    1. **Chat (指令/生成)**：
       - **输入框**：“写一段主角走进酒馆的描写，气氛要压抑。”
       - **流式卡片**：AI 的回答不是纯文本，而是包含“思维链”的卡片。
         - *Status*: `🔍 正在检索：艾琳（第12章状态）...`
         - *Status*: `📚 参考素材：酒馆环境描写模板...`
         - *Output*: 生成的草稿文本。底部带“复制到正文”按钮。
    2. **Context (当前上下文)**：
       - **RAG 透视眼**：显示 AI **当前看到**的设定。
       - *示例*：如果你正在写第 15 章，这里会列出：“主角等级：Lv.20”、“当前地图：黑风寨”、“活跃人物：艾琳 (v2 版)”。
       - *作用*：让用户确信 AI 没有“幻觉”或读取了过期的设定。
    3. **Toolkit (素材箱)**：
       - 随机生成器（姓名、招式）。
       - 预设的描写片段库（用户可收藏）。

    ------

    ## 4. 核心页面三：时空百科全书 (The Dynamic Wiki)

    *对应“业务需求 F8”，用于管理和查看设定。*

    ### 页面布局

    - **顶部：时间轴滑块 (Timeline Slider)**
      - 这是一个核心创新交互。滑块范围从 `Chapter 1` 到 `Current Chapter`。
      - **交互**：拖动滑块到 `Chapter 10`，下方的所有人物卡片数值会自动回退到第 10 章时的状态（由数据库 `valid_from/valid_to` 字段控制）。

    ### 内容区域

    - **实体网格**：展示人物、地点、道具的卡片。
    - **版本对比视图**：
      - 点击“艾琳”卡片，进入详情页。
      - 左侧显示“当前属性”，右侧显示“历史版本记录”。
      - **新增设定/修补**：
        - 点击“修订设定” -> 弹出表单。
        - **必填项**：“从哪一章开始生效？”（默认为当前最新章）。
        - *若用户选择过去的章节（如第 5 章），系统弹出警告：这可能会导致第 5 章之后的内容逻辑冲突。*

    ------

    ## 5. 前端关键技术实现细节

    ### 5.1 流式渲染 (Streaming UI)

    利用 `ai/rsc` (Vercel AI SDK) 或原生 `EventSource`。

    - **场景**：当右侧 Agent 生成正文时。
    - **效果**：
      1. 先显示一个 loading 骨架屏。
      2. 弹出 "Thinking..." 折叠块（展示 LangGraph 的中间步骤）。
      3. 正文内容逐字打字机效果输出。

    ### 5.2 乐观更新 (Optimistic Updates)

    - **场景**：用户在左侧栏勾选“完成本章大纲节点 1”。
    - **效果**：界面立即划掉该节点，无需等待后端 DB 返回。如果后端失败，再回滚并提示错误。

    ### 5.3 编辑器与 Agent 的联动

    - **Context 注入**：当用户在编辑器中光标停留在“雷炎剑”这个词上时，右侧 Copilot 的 Context 面板自动高亮显示“雷炎剑”的设定说明（通过 Tiptap 的 selection API 获取当前词，触发防抖查询）。

    ------

    ## 总结

    这套 UI/UX 设计旨在解决网文作者的痛点：

    1. **创世纪页面**解决“开头难”，通过对话把脑洞变成大纲。
    2. **工作台页面**解决“来回切窗口查设定”的麻烦，右侧 Copilot 自动把需要的 RAG 资料喂到手边。
    3. **Wiki 页面**解决“吃书”问题，通过时间轴滑块清晰管理长篇小说的动态设定。